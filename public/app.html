<!DOCTYPE html>
<html lang="ro">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Character Network - Interactive Visualization</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <link
            href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=Space+Mono:wght@400;700&display=swap"
            rel="stylesheet">
        <style>
        :root {
            --bg-dark: #0a0e1a;
            --bg-panel: #151925;
            --text-primary: #e8eaed;
            --text-secondary: #9195a0;
            --accent-gold: #d4af37;
            --accent-blue: #4a90e2;
            --accent-purple: #8b5cf6;
            --accent-red: #ef4444;
            --border: #2a2f3e;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 40px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 1.8em;
            font-weight: 300;
            letter-spacing: 2px;
            color: var(--accent-gold);
        }

        .header-stats {
            display: flex;
            gap: 30px;
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .stat-item strong {
            color: var(--text-primary);
            margin-left: 5px;
        }

        .control-panel {
            position: fixed;
            top: 80px;
            left: 0;
            width: 320px;
            height: calc(100vh - 80px);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 30px;
            overflow-y: auto;
            z-index: 50;
        }

        .control-section {
            margin-bottom: 30px;
        }

        .control-section h3 {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent-gold);
            margin-bottom: 15px;
            font-weight: 600;
        }

        .control-section label {
            display: block;
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 2px;
            background: var(--border);
            outline: none;
            opacity: 0.8;
            transition: opacity 0.2s;
            -webkit-appearance: none;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-gold);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-gold);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .filter-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        .btn.active {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        .btn-export {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .btn-export:hover {
            background: #3a7bc8;
        }

        .slider-value {
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
            color: var(--accent-gold);
            margin-top: 5px;
        }

        #network-container {
            position: fixed;
            top: 80px;
            left: 320px;
            right: 0;
            height: calc(100vh - 80px);
            background: radial-gradient(circle at 50% 50%, #0f1420 0%, var(--bg-dark) 100%);
        }

        .tooltip {
            position: fixed;
            background: rgba(21, 25, 37, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--accent-gold);
            padding: 15px;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 300px;
            font-size: 0.9em;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .tooltip-title {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 8px;
        }

        .tooltip-stat {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 0.85em;
        }

        .tooltip-stat-label {
            color: var(--text-secondary);
        }

        .tooltip-stat-value {
            color: var(--text-primary);
            font-family: 'Space Mono', monospace;
        }

        .legend {
            position: fixed;
            bottom: 30px;
            left: 340px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 20px;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--accent-gold);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .legend-line {
            width: 40px;
            height: 2px;
            margin-right: 10px;
        }

        .legend-direct {
            background: var(--accent-blue);
        }

        .legend-copresence {
            background: var(--accent-purple);
            opacity: 0.5;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node:hover {
            stroke-width: 3px !important;
        }

        .node-label {
            font-family: 'Crimson Pro', serif;
            font-size: 11px;
            font-weight: 400;
            pointer-events: none;
            text-shadow: 0 0 3px var(--bg-dark), 0 0 3px var(--bg-dark);
        }

        .link {
            transition: all 0.3s;
        }

        .link-direct {
            stroke: var(--accent-blue);
        }

        .link-copresence {
            stroke: var(--accent-purple);
            opacity: 0.4;
        }

        .link.highlighted {
            opacity: 1 !important;
            stroke-width: 3px !important;
        }

        .link.dimmed {
            opacity: 0.1 !important;
        }

        .node.highlighted {
            stroke-width: 3px !important;
        }

        .node.dimmed {
            opacity: 0.3 !important;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: var(--accent-gold);
            font-family: 'Space Mono', monospace;
        }

        .drawer {
            position: fixed;
            top: 80px;
            right: -500px;
            width: 500px;
            height: calc(100vh - 80px);
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            box-shadow: -5px 0 20px rgba(0,0,0,0.3);
            transition: right 0.3s ease-out;
            z-index: 200;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .drawer.open {
            right: 0;
        }

        .drawer-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .drawer-title {
            font-size: 1.3em;
            font-weight: 300;
            color: var(--accent-gold);
            letter-spacing: 1px;
        }

        .drawer-close {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-primary);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.2em;
        }

        .drawer-close:hover {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        .drawer-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: rgba(0,0,0,0.2);
        }

        .drawer-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .drawer-tab:hover {
            color: var(--text-primary);
            background: rgba(255,255,255,0.05);
        }

        .drawer-tab.active {
            color: var(--accent-gold);
            border-bottom-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.1);
        }

        .drawer-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden; 
            padding: 20px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .character-profile {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .profile-header {
            text-align: center;
            padding: 20px;
            background: rgba(212, 175, 55, 0.1);
            border-radius: 8px;
            border: 1px solid var(--accent-gold);
        }

        .profile-name {
            font-size: 1.5em;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 8px;
        }

        .profile-gender {
            font-size: 1.1em;
            color: var(--text-secondary);
        }

        .profile-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .stat-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: 600;
            color: var(--accent-gold);
            font-family: 'Space Mono', monospace;
        }

        .chart-container {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--border);
            overflow: hidden;  
        }

        .chart-container svg {
            max-width: 100%;  
            height: auto;
        }

        .chart-title {
            font-size: 0.9em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        .connections-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .search-box, .filter-select {
            padding: 8px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 0.9em;
        }

        .search-box {
            flex: 1;
            min-width: 150px;
        }

        .search-box:focus, .filter-select:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .partners-table {
            overflow-x: auto;
        }

        .partners-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .partners-table th {
            background: rgba(255,255,255,0.1);
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            color: var(--accent-gold);
            border-bottom: 2px solid var(--border);
            cursor: pointer;
            user-select: none;
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .partners-table th:hover {
            background: rgba(255,255,255,0.15);
        }

        .partners-table td {
            padding: 12px 8px;
            border-bottom: 1px solid var(--border);
        }

        .partners-table tr {
            transition: background 0.2s;
            cursor: pointer;
        }

        .partners-table tr:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .partner-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .gender-icon {
            display: inline-block;
            width: 20px;
            text-align: center;
            margin-right: 5px;
        }

        .gender-M { color: var(--accent-blue); }
        .gender-F { color: var(--accent-pink); }
        .gender-C { color: var(--accent-purple); }

        .metric-cell {
            font-family: 'Space Mono', monospace;
            color: var(--text-secondary);
        }

        .metric-bar {
            height: 4px;
            background: var(--accent-gold);
            border-radius: 2px;
            margin-top: 4px;
        }

        .vampire-avatar {
            filter: drop-shadow(0 0 8px rgba(239, 68, 68, 0.6));
            animation: vampirePulse 2s ease-in-out infinite;
        }

        .vampire-true-form {
            filter: drop-shadow(0 0 12px rgba(139, 92, 246, 0.8));
            animation: trueFormPulse 3s ease-in-out infinite;
        }

        @keyframes vampirePulse {
            0%, 100% { 
                filter: drop-shadow(0 0 8px rgba(239, 68, 68, 0.6));
            }
            50% { 
                filter: drop-shadow(0 0 15px rgba(239, 68, 68, 0.9));
            }
        }

        @keyframes trueFormPulse {
            0%, 100% { 
                filter: drop-shadow(0 0 12px rgba(139, 92, 246, 0.8));
            }
            50% { 
                filter: drop-shadow(0 0 20px rgba(139, 92, 246, 1));
            }
        }

        .vampire-connection {
            stroke: #8b5cf6;
            stroke-dasharray: 5, 5;
            opacity: 0.4;
            animation: dashAnimation 20s linear infinite;
        }

        @keyframes dashAnimation {
            to {
                stroke-dashoffset: -1000;
            }
        }

        .btn-vampire-toggle {
            background: linear-gradient(135deg, #ef4444 0%, #8b5cf6 100%);
            border: none;
            color: white;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .btn-vampire-toggle::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.5s;
        }

        .btn-vampire-toggle:hover::before {
            left: 100%;
        }

        .btn-vampire-toggle.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #ef4444 100%);
        }

        .vampire-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #ef4444, #8b5cf6);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .vampire-merged {
            filter: drop-shadow(0 0 20px rgba(139, 92, 246, 1));
        }

        .identity-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .identity-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .identity-card:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: #8b5cf6;
        }

        .identity-card.true-form {
            grid-column: 1 / -1;
            background: rgba(139, 92, 246, 0.15);
            border-color: #8b5cf6;
        }

        .identity-name {
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 5px;
        }

        .identity-stat {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .merged-stats-box {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid #8b5cf6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .merge-animation {
            animation: mergeCollapse 0.5s ease-out forwards;
        }

        @keyframes mergeCollapse {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.3);
            }
        }

        .expand-animation {
            animation: expandSplit 0.5s ease-out forwards;
        }

        @keyframes expandSplit {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .node-fade-in {
            animation: fadeIn 0.5s ease-in forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .node-fade-out {
            animation: fadeOut 0.3s ease-out forwards;
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }
    </style>
    </head>
    <body>
        <div class="header">
            <h1>CHARACTER NETWORK</h1>
            <div class="header-stats">
                <div class="stat-item">Characters: <strong
                        id="stat-nodes">0</strong></div>
                <div class="stat-item">Relationships: <strong
                        id="stat-edges">0</strong></div>
                <div class="stat-item">Communities: <strong
                        id="stat-communities">0</strong></div>
            </div>
            <form method="POST" action="/logout" style="margin:0;">
                <button class="btn" style="padding:10px 12px;">Logout</button>
            </form>
        </div>

        <div class="control-panel">
            <div class="control-section">
                <h3>Importance Filter</h3>
                <label>Minimum dialogues: <span id="min-dialogues-value"
                        class="slider-value">0</span></label>
                <input type="range" id="min-dialogues" min="0" max="100"
                    value="0" step="1">
            </div>

            <div class="control-section">
                <h3>Relationship Filter</h3>
                <label>Minimum weight: <span id="min-weight-value"
                        class="slider-value">0</span></label>
                <input type="range" id="min-weight" min="0" max="50" value="0"
                    step="1">
            </div>

            <div class="control-section">
                <h3>Relationship Type</h3>
                <div class="filter-buttons">
                    <button class="btn active" data-filter="all">All</button>
                    <button class="btn" data-filter="direct">Direct
                        Only</button>
                    <button class="btn" data-filter="copresence">Co-presence
                        Only</button>
                </div>
            </div>

            <div class="control-section">
                <h3>Visualization</h3>
                <div class="filter-buttons">
                    <button class="btn" id="toggle-labels">Toggle
                        Labels</button>
                    <button class="btn" id="reset-zoom">Reset Zoom</button>
                </div>
            </div>

            <div class="control-section">
                <h3>Vampire Identity</h3>
                <div class="filter-buttons">
                    <button class="btn btn-vampire-toggle" id="vampire-toggle">
                        Merge Vampire
                    </button>
                </div>
                <p
                    style="font-size: 0.7em; color: var(--text-secondary); margin-top: 8px; line-height: 1.3;">
                    Combine 4 personas into one entity
                </p>
            </div>

            <div class="control-section">
                <h3>Export</h3>
                <div class="filter-buttons">
                    <button class="btn btn-export" id="export-svg">Export
                        SVG</button>
                    <button class="btn btn-export" id="export-png">Export
                        PNG</button>
                </div>
            </div>
        </div>

        <div id="network-container"></div>

        <div class="legend">
            <div class="legend-title">Relationship Types</div>
            <div class="legend-item">
                <div class="legend-line legend-direct"></div>
                <span>Direct Dialogue</span>
            </div>
            <div class="legend-item">
                <div class="legend-line legend-copresence"></div>
                <span>Co-presence</span>
            </div>
        </div>

        <div class="drawer" id="drawer">
            <div class="drawer-header">
                <h2 class="drawer-title" id="drawer-title">Character
                    Analysis</h2>
                <button class="drawer-close" onclick="closeDrawer()">‚úï</button>
            </div>

            <div class="drawer-tabs">
                <button class="drawer-tab active" data-tab="overview"
                    onclick="switchTab('overview')">Overview</button>
                <button class="drawer-tab" data-tab="connections"
                    onclick="switchTab('connections')">Connections</button>
                <button class="drawer-tab" data-tab="community"
                    onclick="switchTab('community')">Community</button>
                <button class="drawer-tab" data-tab="sentiment"
                    onclick="switchTab('sentiment')" id="sentiment-tab">
                    Sentiment
                </button>
                <button class="drawer-tab" data-tab="identity"
                    onclick="switchTab('identity')" style="display: none;"
                    id="identity-tab">
                    True Identity
                </button>
            </div>

            <div class="drawer-content">
                <div class="tab-panel active" id="tab-overview">
                    <div class="character-profile" id="character-profile">
                    </div>
                </div>

                <div class="tab-panel" id="tab-connections">
                    <div class="connections-controls">
                        <input type="text" class="search-box"
                            id="partner-search"
                            placeholder="Search partners...">
                        <select class="filter-select" id="gender-filter">
                            <option value="all">All Genders</option>
                            <option value="M">Male</option>
                            <option value="F">Female</option>
                            <option value="C">Collective</option>
                        </select>
                        <select class="filter-select" id="sort-by">
                            <option value="weight">By Weight</option>
                            <option value="direct">By Direct</option>
                            <option value="words">By Words</option>
                        </select>
                    </div>
                    <div class="partners-table" id="partners-table">
                    </div>
                </div>

                <div class="tab-panel" id="tab-community">
                    <div class="community-info" id="community-info">
                    </div>
                </div>

                <div class="tab-panel" id="tab-sentiment">
                    <div class="sentiment-info" id="sentiment-info">
                    </div>
                </div>

                <div class="tab-panel" id="tab-identity">
                    <div class="identity-info" id="identity-info">
                    </div>
                </div>
            </div>
        </div>

        <div class="tooltip" id="tooltip"></div>

        <div class="loading" id="loading">Loading network data...</div>

        <script>
        let networkData = null;
        let svg, g, simulation, link, node, label, zoom;
        let showLabels = true;
        let currentFilter = 'all';
        let selectedCharacter = null;
        let vampireMerged = false;
        let vampireAvatars = [];
        let vampireMergedNode = null;

        const communityColors = [
            '#FFB347', '#87CEEB', '#DDA0DD', '#F08080',
            '#90EE90', '#F0E68C', '#FFB6C1', '#20B2AA'
        ];

        const genderIcons = {
            'M': '‚ôÇ',
            'F': '‚ôÄ',
            'C': 'üë•',
            'Unknown': '?'
        };

        function openDrawer(characterData) {
            selectedCharacter = characterData;
            document.getElementById('drawer').classList.add('open');
            document.getElementById('drawer-title').textContent = characterData.label;
            
            renderOverviewTab(characterData);
            renderConnectionsTab(characterData);
            renderCommunityTab(characterData);
            renderSentimentTab(characterData);
        }

        function closeDrawer() {
            document.getElementById('drawer').classList.remove('open');
            selectedCharacter = null;
            
            link.classed('highlighted', false).classed('dimmed', false);
            node.classed('highlighted', false).classed('dimmed', false);
        }

        function switchTab(tabName) {
            document.querySelectorAll('.drawer-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }

        function renderOverviewTab(char) {
            const container = document.getElementById('character-profile');
            const ca = char.connections_analysis || {};
            
            const genderIcon = genderIcons[char.gender] || genderIcons['Unknown'];
            const genderLabel = char.gender === 'M' ? 'Male' : 
                                char.gender === 'F' ? 'Female' : 
                                char.gender === 'C' ? 'Collective' : 'Unknown';
                
            const isSilentOnly = char.dialogue_count === 0 && (ca.total_connections || 0) > 0;
            
            container.innerHTML = `
                <div class="profile-header">
                    <div class="profile-name">${char.label}</div>
                    <div class="profile-gender">${genderIcon} ${genderLabel}</div>
                </div>
                
                ${isSilentOnly ? `
                    <div style="background: rgba(255,193,7,0.15); border: 1px solid rgba(255,193,7,0.4); padding: 12px 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 20px;">üëÅÔ∏è</span>
                            <div>
                                <div style="color: #ffc107; font-weight: 600; margin-bottom: 3px;">Silent Participant Only</div>
                                <div style="color: var(--text-secondary); font-size: 0.9em;">
                                    This character appears in scenes but never speaks.
                                    <br>Connections and centrality are based on <strong>co-presence</strong> with other characters.
                                </div>
                            </div>
                        </div>
                    </div>
                ` : ''}
                
                <div class="profile-stats">
                    <div class="stat-box">
                        <div class="stat-label">Dialogues</div>
                        <div class="stat-value">${char.dialogue_count}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Connections</div>
                        <div class="stat-value">${ca.total_connections || 0}</div>
                        ${isSilentOnly ? `<div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 3px;">via co-presence</div>` : ''}
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total Words</div>
                        <div class="stat-value">${(ca.total_words_exchanged || 0).toLocaleString()}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Centrality</div>
                        <div class="stat-value">${(char.degree_centrality * 100).toFixed(1)}%</div>
                        ${isSilentOnly ? `<div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 3px;">observer role</div>` : ''}
                    </div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">Gender Distribution of Partners</div>
                    <div id="gender-chart"></div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">Top 5 Partners</div>
                    <div id="top-partners-chart"></div>
                </div>
            `;
            
            if (ca.gender_distribution) {
                renderGenderChart(ca.gender_distribution);
            }
            if (ca.top_5_partners) {
                renderTopPartnersChart(ca.top_5_partners);
            }
        }

        function renderGenderChart(genderDist) {
            const container = d3.select('#gender-chart');
            container.html('');
            
            const data = Object.entries(genderDist)
                .filter(([k, v]) => v > 0)
                .map(([key, value]) => ({ gender: key, count: value }));
            
            if (data.length === 0) return;
            
            const width = 420;  
            const height = 120;
            const barHeight = 25;
            const labelWidth = 90;  
            
            const x = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.count)])
                .range([0, width - labelWidth - 50]);  
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', data.length * (barHeight + 5));
            
            const bars = svg.selectAll('g')
                .data(data)
                .join('g')
                .attr('transform', (d, i) => `translate(0, ${i * (barHeight + 5)})`);
            
            bars.append('rect')
                .attr('x', labelWidth)
                .attr('width', d => x(d.count))
                .attr('height', barHeight)
                .attr('fill', d => {
                    if (d.gender === 'M') return '#4a90e2';
                    if (d.gender === 'F') return '#ec4899';
                    if (d.gender === 'C') return '#8b5cf6';
                    return '#666';
                })
                .attr('opacity', 0.8);
            
            bars.append('text')
                .attr('x', labelWidth - 5)
                .attr('y', barHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'end')
                .attr('fill', '#9195a0')
                .style('font-size', '11px')
                .text(d => {
                    const icon = genderIcons[d.gender] || '?';
                    const label = d.gender === 'M' ? 'Male' : 
                                    d.gender === 'F' ? 'Female' : 
                                    d.gender === 'C' ? 'Collective' : 'Unknown';
                    return `${icon} ${label}`;
                });
            
            bars.append('text')
                .attr('x', d => labelWidth + x(d.count) + 5)
                .attr('y', barHeight / 2)
                .attr('dy', '0.35em')
                .attr('fill', '#e8eaed')
                .style('font-size', '13px')
                .style('font-weight', 'bold')
                .text(d => d.count);
        }

        function renderTopPartnersChart(partners) {
            const container = d3.select('#top-partners-chart');
            container.html('');
            
            if (!partners || partners.length === 0) return;
            
            const width = 420;  
            const barHeight = 30;
            const height = partners.length * (barHeight + 5);
            const labelWidth = 130;  
            
            const maxWeight = d3.max(partners, d => d.weight);
            
            const x = d3.scaleLinear()
                .domain([0, maxWeight])
                .range([0, width - labelWidth - 60]);  
            
            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const bars = svg.selectAll('g')
                .data(partners)
                .join('g')
                .attr('transform', (d, i) => `translate(0, ${i * (barHeight + 5)})`);
            
            bars.append('rect')
                .attr('x', labelWidth)
                .attr('width', d => x(d.weight))
                .attr('height', barHeight)
                .attr('fill', '#d4af37')
                .attr('opacity', 0.7);
            
            bars.append('text')
                .attr('x', labelWidth - 5)
                .attr('y', barHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'end')
                .attr('fill', '#e8eaed')
                .style('font-size', '10px')
                .text(d => {
                    const icon = genderIcons[d.gender] || '';
                    const maxLen = 18;
                    const name = d.name.length > maxLen ? d.name.substring(0, maxLen) + '...' : d.name;
                    return `${icon} ${name}`;
                });
            
            bars.append('text')
                .attr('x', d => labelWidth + x(d.weight) + 5)
                .attr('y', barHeight / 2)
                .attr('dy', '0.35em')
                .attr('fill', '#d4af37')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text(d => d.weight);
        }

        function renderConnectionsTab(char) {
            const ca = char.connections_analysis || {};
            const partners = ca.partners || [];
            
            const searchBox = document.getElementById('partner-search');
            const genderFilter = document.getElementById('gender-filter');
            const sortBy = document.getElementById('sort-by');
            
            function updateTable() {
                let filtered = [...partners];
                
                const searchTerm = searchBox.value.toLowerCase();
                if (searchTerm) {
                    filtered = filtered.filter(p => p.name.toLowerCase().includes(searchTerm));
                }
                
                const genderValue = genderFilter.value;
                if (genderValue !== 'all') {
                    filtered = filtered.filter(p => p.gender === genderValue);
                }
                
                const sortValue = sortBy.value;
                filtered.sort((a, b) => b[sortValue] - a[sortValue]);
                
                renderPartnersTable(filtered);
            }
            
            searchBox.addEventListener('input', updateTable);
            genderFilter.addEventListener('change', updateTable);
            sortBy.addEventListener('change', updateTable);
            
            updateTable();
        }

        function renderPartnersTable(partners) {
            const container = document.getElementById('partners-table');
            
            if (!partners || partners.length === 0) {
                container.innerHTML = '<p style="color: #9195a0; text-align: center; padding: 20px;">No partners found</p>';
                return;
            }
            
            const maxWeight = Math.max(...partners.map(p => p.weight));
            
            const html = `
                <table>
                    <thead>
                        <tr>
                            <th>Partner</th>
                            <th>Direct</th>
                            <th>Co-pres</th>
                            <th>Words</th>
                            <th>Weight</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${partners.map(p => {
                            const icon = genderIcons[p.gender] || '';
                            const genderClass = p.gender ? `gender-${p.gender}` : '';
                            const barWidth = (p.weight / maxWeight) * 100;
                            
                            return `
                                <tr onmouseover="highlightConnection('${selectedCharacter.id}', '${p.name}')" 
                                    onmouseout="clearConnectionHighlight()">
                                    <td class="partner-name">
                                        <span class="gender-icon ${genderClass}">${icon}</span>
                                        ${p.name}
                                    </td>
                                    <td class="metric-cell">${p.direct_dialogues}</td>
                                    <td class="metric-cell">${p.copresence}</td>
                                    <td class="metric-cell">${p.total_words.toLocaleString()}</td>
                                    <td class="metric-cell">
                                        ${p.weight}
                                        <div class="metric-bar" style="width: ${barWidth}%"></div>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;
            
            container.innerHTML = html;
        }

        function highlightConnection(sourceId, targetId) {
            link.each(function(d) {
                const isConnected = (d.source.id === sourceId && d.target.id === targetId) ||
                                    (d.target.id === sourceId && d.source.id === targetId);
                d3.select(this).classed('highlighted', isConnected)
                                .classed('dimmed', !isConnected);
            });
            
            node.each(function(d) {
                const isHighlighted = d.id === sourceId || d.id === targetId;
                d3.select(this).classed('highlighted', isHighlighted)
                                .classed('dimmed', !isHighlighted);
            });
        }

        function clearConnectionHighlight() {
            link.classed('highlighted', false).classed('dimmed', false);
            node.classed('highlighted', false).classed('dimmed', false);
        }

        function showMessage(text, type) {
            console.log(`${type}: ${text}`);
        }

        function renderCommunityTab(char) {
            const container = document.getElementById('community-info');
            const ca = char.connections_analysis || {};
            const communityMembers = ca.community_members || [];
            
            container.innerHTML = `
                <div class="stat-box">
                    <div class="stat-label">Community ID</div>
                    <div class="stat-value">${char.community}</div>
                </div>
                
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="chart-title">Community Members (${communityMembers.length})</div>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${communityMembers.map(member => `
                            <div style="padding: 8px; border-bottom: 1px solid var(--border); color: var(--text-primary);">
                                ${member}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function renderSentimentTab(char) {
            const container = document.getElementById('sentiment-info');
            
            const hasDialogues = char.dialogue_count > 0;
            
            if (!char.sentiment_profile && !char.emotion_profile) {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        ${!hasDialogues ? `
                            <p style="color: var(--text-secondary); margin-bottom: 15px;">
                                ‚ö†Ô∏è This character has no spoken dialogues.
                                <br><br>
                                <strong>${char.label}</strong> appears only as a silent participant or listener.
                            </p>
                        ` : `
                            <p style="color: var(--text-secondary); margin-bottom: 15px;">
                                No sentiment data available for this character.
                            </p>
                            <div style="background: rgba(255,193,7,0.1); border: 1px solid rgba(255,193,7,0.3); padding: 15px; border-radius: 8px; text-align: left; margin-top: 15px;">
                                <div style="color: #ffc107; font-weight: 600; margin-bottom: 8px;">üí° To add sentiment data:</div>
                                <ol style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.6; margin-left: 20px;">
                                    <li>Run sentiment analysis on dialogues</li>
                                    <li>Run <code style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">network_analysis_with_sentiment.py</code></li>
                                    <li>Reload this page</li>
                                </ol>
                            </div>
                        `}
                    </div>
                `;
                return;
            }
            
            const sentiment = char.sentiment_profile || {};
            const emotions = char.emotion_profile || {};
            
            const sentDist = sentiment.distribution || {};
            const totalSentiment = (sentDist.positive || 0) + (sentDist.neutral || 0) + (sentDist.negative || 0);
            
            const emotionDist = emotions.distribution || {};
            const sortedEmotions = Object.entries(emotionDist).sort((a, b) => b[1] - a[1]);
            
            function getSentimentColor(label) {
                if (label === 'positive') return '#10b981';
                if (label === 'negative') return '#ef4444';
                return '#6b7280';
            }
            
            function getEmotionColor(emotion) {
                const colors = {
                    anger: '#ef4444',
                    disgust: '#a855f7',
                    fear: '#f59e0b',
                    joy: '#10b981',
                    neutral: '#6b7280',
                    sadness: '#3b82f6',
                    surprise: '#ec4899'
                };
                return colors[emotion] || '#6b7280';
            }
            
            container.innerHTML = `
                <div class="stat-box" style="background: linear-gradient(135deg, ${getSentimentColor(sentiment.dominant)}22, ${getSentimentColor(sentiment.dominant)}11); border: 1px solid ${getSentimentColor(sentiment.dominant)};">
                    <div class="stat-label">Dominant Sentiment</div>
                    <div class="stat-value" style="color: ${getSentimentColor(sentiment.dominant)}; text-transform: capitalize;">
                        ${sentiment.dominant || 'N/A'}
                    </div>
                    <div style="font-size: 0.85em; color: var(--text-secondary); margin-top: 5px;">
                        Score: ${sentiment.score !== undefined ? sentiment.score.toFixed(3) : 'N/A'}
                        <span style="margin-left: 10px;">Dialogues: ${sentiment.total_dialogues || 0}</span>
                    </div>
                </div>
                
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="chart-title">Sentiment Distribution</div>
                    <div style="margin-top: 15px;">
                        ${totalSentiment > 0 ? Object.entries(sentDist).map(([label, count]) => {
                            const pct = (count / totalSentiment * 100).toFixed(1);
                            const color = getSentimentColor(label);
                            return `
                                <div style="margin-bottom: 12px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                        <span style="text-transform: capitalize; color: var(--text-primary);">${label}</span>
                                        <span style="color: var(--text-secondary);">${count} (${pct}%)</span>
                                    </div>
                                    <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; overflow: hidden;">
                                        <div style="width: ${pct}%; height: 100%; background: ${color}; border-radius: 4px;"></div>
                                    </div>
                                </div>
                            `;
                        }).join('') : '<p style="color: var(--text-secondary);">No sentiment data.</p>'}
                    </div>
                </div>
                
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="chart-title">Emotion Profile</div>
                    <div style="margin-top: 15px;">
                        ${emotions.distribution && sortedEmotions.length > 0 ? `
                            <div class="stat-box" style="margin-bottom: 15px;">
                                <div class="stat-label">Dominant Emotion</div>
                                <div class="stat-value" style="color: ${getEmotionColor(emotions.dominant)}; text-transform: capitalize;">
                                    ${emotions.dominant || 'N/A'}
                                </div>
                            </div>
                            ${sortedEmotions.map(([emotion, count]) => {
                                const pct = emotions.total > 0 ? (count / emotions.total * 100).toFixed(1) : 0;
                                const color = getEmotionColor(emotion);
                                return `
                                    <div style="margin-bottom: 12px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                            <span style="text-transform: capitalize; color: var(--text-primary);">${emotion}</span>
                                            <span style="color: var(--text-secondary);">${count} (${pct}%)</span>
                                        </div>
                                        <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; overflow: hidden;">
                                            <div style="width: ${pct}%; height: 100%; background: ${color}; border-radius: 4px;"></div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        ` : '<p style="color: var(--text-secondary);">No emotion data available.</p>'}
                    </div>
                </div>
            `;
        }

        function isVampireAvatar(node) {
            return node.meta_identity === 'Vampirul';
        }

        function initializeVampireSystem() {
            console.log('Initializing vampire system...');
            console.log('Total nodes:', networkData.nodes.length);
            
            const nodesWithMeta = networkData.nodes.filter(n => n.meta_identity);
            console.log('Nodes with meta_identity:', nodesWithMeta.length, nodesWithMeta.map(n => ({id: n.id, meta: n.meta_identity, type: n.identity_type})));
            
            vampireAvatars = networkData.nodes.filter(n => n.meta_identity === 'Vampirul');
            console.log('Vampire avatars found:', vampireAvatars.length, vampireAvatars.map(a => ({id: a.id, type: a.identity_type})));
            
            if (vampireAvatars.length === 0) {
                console.error('No vampire avatars found! Check that metadata is loaded correctly.');
            }
        }

        function toggleVampireMerge() {
            vampireMerged = !vampireMerged;
            const btn = document.getElementById('vampire-toggle');
            
            console.log('Toggle clicked! vampireMerged:', vampireMerged);
            
            if (vampireMerged) {
                btn.classList.add('active');
                btn.innerHTML = 'üé≠ Split Vampire';
                mergeVampireIdentities();
            } else {
                btn.classList.remove('active');
                btn.innerHTML = 'üé≠ Merge Vampire';
                splitVampireIdentities();
            }
        }

        function mergeVampireIdentities() {
            console.log('MERGING vampire identities...');
            
            if (vampireAvatars.length === 0) {
                console.error('No vampire avatars found!');
                return;
            }
            
            const trueForm = vampireAvatars.find(a => a.identity_type === 'true_form') || vampireAvatars[0];
            
            const totalDialogues = vampireAvatars.reduce((sum, a) => sum + a.dialogue_count, 0);
            
            const totalWords = vampireAvatars.reduce((sum, a) => {
                const ca = a.connections_analysis;
                return sum + (ca ? (ca.total_words_exchanged || 0) : 0);
            }, 0);
            
            const partnersMap = new Map();
            let totalWordsExchanged = 0;
            const genderDist = {'M': 0, 'F': 0, 'C': 0, 'Unknown': 0};
            
            vampireAvatars.forEach(avatar => {
                const ca = avatar.connections_analysis;
                if (ca && ca.partners) {
                    ca.partners.forEach(p => {
                        const isVampire = vampireAvatars.some(v => v.id === p.name);
                        if (isVampire) return;
                        
                        if (partnersMap.has(p.name)) {
                            const existing = partnersMap.get(p.name);
                            existing.direct_dialogues += p.direct_dialogues || 0;
                            existing.copresence += p.copresence || 0;
                            existing.total_words += p.total_words || 0;
                            existing.weight += p.weight || 0;
                        } else {
                            partnersMap.set(p.name, {
                                name: p.name,
                                gender: p.gender,
                                direct_dialogues: p.direct_dialogues || 0,
                                copresence: p.copresence || 0,
                                total_words: p.total_words || 0,
                                weight: p.weight || 0
                            });
                            
                            const g = p.gender || 'Unknown';
                            if (g in genderDist) genderDist[g]++;
                        }
                        
                        totalWordsExchanged += p.total_words || 0;
                    });
                }
            });
            
            const allPartners = Array.from(partnersMap.values()).sort((a, b) => b.weight - a.weight);
            
            const avgX = vampireAvatars.reduce((sum, a) => sum + (a.x || 0), 0) / vampireAvatars.length;
            const avgY = vampireAvatars.reduce((sum, a) => sum + (a.y || 0), 0) / vampireAvatars.length;
            
            vampireMergedNode = {
                id: 'Vampirul (Merged)',
                label: 'Vampirul (True Form)',
                x: avgX,
                y: avgY,
                fx: avgX,  
                fy: avgY,  
                dialogue_count: totalDialogues,
                word_count: totalWords,
                degree: allPartners.length,
                degree_centrality: trueForm.degree_centrality,
                betweenness_centrality: trueForm.betweenness_centrality,
                closeness_centrality: trueForm.closeness_centrality,
                eigenvector_centrality: trueForm.eigenvector_centrality,
                community: trueForm.community,
                gender: 'M',
                meta_identity: 'Vampirul',
                identity_type: 'merged',
                connections_analysis: {
                    partners: allPartners,
                    top_5_partners: allPartners.slice(0, 5),
                    gender_distribution: genderDist,
                    total_words_exchanged: totalWordsExchanged,
                    total_connections: allPartners.length
                },
                avatars: vampireAvatars.map(a => ({
                    name: a.id,
                    dialogues: a.dialogue_count,
                    words: (a.connections_analysis ? (a.connections_analysis.total_words_exchanged || 0) : 0),
                    type: a.identity_type
                }))
            };
            
            console.log('Created merged node:', vampireMergedNode);
            
            vampireAvatars.forEach(avatar => {
                avatar.hidden = true;
            });
            
            networkData.nodes.push(vampireMergedNode);
            
            console.log('Total nodes now:', networkData.nodes.length);
            console.log('Hidden nodes:', networkData.nodes.filter(n => n.hidden).length);
            
            renderNetwork();
            
            setTimeout(() => {
                if (vampireMerged) {
                    simulation.alpha(0).stop();
                    console.log('Simulation stopped - merged node stabilized');
                }
            }, 1000);
        }

        function splitVampireIdentities() {
            console.log('SPLITTING vampire identities...');
            
            vampireAvatars.forEach(avatar => {
                avatar.hidden = false;
            });
            
            const mergedIndex = networkData.nodes.findIndex(n => n.id === 'Vampirul (Merged)');
            if (mergedIndex > -1) {
                networkData.nodes.splice(mergedIndex, 1);
                console.log('Removed merged node');
            }
            
            vampireMergedNode = null;
            
            console.log('Total nodes now:', networkData.nodes.length);
            
            renderNetwork();
            
            setTimeout(() => {
                simulation.alpha(0.3).restart();
                console.log('Simulation restarted after split');
            }, 100);
        }

        function renderIdentityTab(char) {
            const container = document.getElementById('identity-info');
            
            if (!isVampireAvatar(char) && char.identity_type !== 'merged') {
                container.innerHTML = '<p style="color: var(--text-secondary); padding: 20px;">This character has no alternate identities.</p>';
                return;
            }
            
            const isMerged = char.identity_type === 'merged';
            const avatarsList = isMerged ? char.avatars : vampireAvatars.map(a => ({
                name: a.id,
                dialogues: a.dialogue_count,
                words: a.connections_analysis?.total_words_exchanged || 0,
                type: a.identity_type
            }));
            
            const totalDialogues = avatarsList.reduce((sum, a) => sum + a.dialogues, 0);
            const totalWords = avatarsList.reduce((sum, a) => sum + (a.words || 0), 0);
            
            container.innerHTML = `
                <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(139, 92, 246, 0.1)); border-radius: 8px; margin-bottom: 20px;">
                    <div style="font-size: 2em; margin-bottom: 10px;">üé≠</div>
                    <h3 style="color: var(--accent-gold); margin-bottom: 5px;">THE VAMPIRE</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9em;">A being of many faces</p>
                </div>
                
                <div class="merged-stats-box">
                    <div style="text-align: center; margin-bottom: 15px;">
                        <div style="font-size: 0.85em; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px;">Combined Statistics</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <div style="font-size: 0.8em; color: var(--text-secondary);">Total Dialogues</div>
                            <div style="font-size: 1.5em; font-weight: bold; color: #8b5cf6;">${totalDialogues}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.8em; color: var(--text-secondary);">Total Words</div>
                            <div style="font-size: 1.5em; font-weight: bold; color: #ef4444;">${totalWords.toLocaleString()}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.8em; color: var(--text-secondary);">Personas</div>
                            <div style="font-size: 1.5em; font-weight: bold; color: var(--accent-gold);">${avatarsList.length}</div>
                        </div>
                        <div>
                            <div style="font-size: 0.8em; color: var(--text-secondary);">Identity</div>
                            <div style="font-size: 1.5em; font-weight: bold; color: #8b5cf6;">Fluid</div>
                        </div>
                    </div>
                </div>
                
                <h4 style="color: var(--accent-gold); margin: 20px 0 10px; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;">Manifestations</h4>
                
                <div class="identity-grid">
                    ${avatarsList.map(avatar => {
                        const isTrueForm = avatar.type === 'true_form';
                        return `
                            <div class="identity-card ${isTrueForm ? 'true-form' : ''}">
                                <div class="identity-name">
                                    ${isTrueForm ? 'üëë ' : 'üé≠ '}${avatar.name}
                                </div>
                                <div class="identity-stat">${avatar.dialogues} dialogues</div>
                                <div class="identity-stat" style="color: ${isTrueForm ? '#8b5cf6' : '#ef4444'};">
                                    ${isTrueForm ? 'True Form' : 'Avatar'}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(139, 92, 246, 0.1); border-left: 3px solid #8b5cf6; border-radius: 4px;">
                    <p style="font-size: 0.9em; line-height: 1.6; color: var(--text-primary); font-style: italic;">
                        "The vampire appears in multiple guises throughout the narrative, 
                        adapting its persona to manipulate and deceive. Each manifestation 
                        serves a purpose in the larger design."
                    </p>
                </div>
            `;
        }

        function openDrawer(characterData) {
            selectedCharacter = characterData;
            document.getElementById('drawer').classList.add('open');
            document.getElementById('drawer-title').textContent = characterData.label;
            
            const identityTab = document.getElementById('identity-tab');
            if (isVampireAvatar(characterData) || characterData.identity_type === 'merged') {
                identityTab.style.display = 'block';
            } else {
                identityTab.style.display = 'none';
            }
            
            renderOverviewTab(characterData);
            renderConnectionsTab(characterData);
            renderCommunityTab(characterData);
            renderSentimentTab(characterData);
            if (isVampireAvatar(characterData) || characterData.identity_type === 'merged') {
                renderIdentityTab(characterData);
            }
        }

        async function loadData() {
            try {
                const response = await fetch('network_data.json');
                networkData = await response.json();
                
                document.getElementById('loading').style.display = 'none';
                updateStats();
                
                initializeVampireSystem();
                
                initVisualization();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').textContent = 'Error loading data';
            }
        }

        function updateStats() {
            document.getElementById('stat-nodes').textContent = networkData.metadata.total_nodes;
            document.getElementById('stat-edges').textContent = networkData.metadata.total_edges;
            document.getElementById('stat-communities').textContent = networkData.metadata.total_communities;
        }

        function initVisualization() {
            const container = document.getElementById('network-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            svg = d3.select('#network-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            g = svg.append('g');

            simulation = d3.forceSimulation(networkData.nodes)
                .force('link', d3.forceLink(networkData.edges)
                    .id(d => d.id)
                    .distance(d => {
                        const directWeight = d.direct || 0;
                        const copresenceWeight = d.copresence || 0;
                        if (directWeight > copresenceWeight) {
                            return 80; 
                        } else {
                            return 150; 
                        }
                    })
                    .strength(d => {
                        const totalWeight = d.weight || 1;
                        return Math.min(totalWeight / 50, 1);
                    }))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(40));

            renderNetwork();
            setupControls();
            setupResize();
        }

        function setupResize() {
            window.addEventListener('resize', () => {
                const container = document.getElementById('network-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                svg.attr('width', width).attr('height', height);

                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            });
        }

        function renderNetwork() {
            const minDialogues = parseInt(document.getElementById('min-dialogues').value);
            const minWeight = parseInt(document.getElementById('min-weight').value);

            let filteredNodes = networkData.nodes.filter(n => {
                if (n.hidden) return false;  
                return n.dialogue_count >= minDialogues;
            });
            const nodeIds = new Set(filteredNodes.map(n => n.id));

            let edgesToUse = networkData.edges;
            if (vampireMerged && vampireMergedNode) {
                edgesToUse = networkData.edges.map(e => {
                    const sourceId = e.source.id || e.source;
                    const targetId = e.target.id || e.target;
                    
                    const sourceIsVampire = vampireAvatars.some(a => a.id === sourceId);
                    const targetIsVampire = vampireAvatars.some(a => a.id === targetId);
                    
                    if (sourceIsVampire && targetIsVampire) {
                        return null;
                    }
                    
                    if (sourceIsVampire) {
                        return {...e, source: vampireMergedNode.id};
                    }
                    if (targetIsVampire) {
                        return {...e, target: vampireMergedNode.id};
                    }
                    
                    return e;
                }).filter(e => e !== null);
            }

            let filteredEdges = edgesToUse.filter(e => {
                if (!nodeIds.has(e.source.id || e.source) || !nodeIds.has(e.target.id || e.target)) {
                    return false;
                }
                if (e.weight < minWeight) return false;

                if (currentFilter === 'direct') {
                    return e.direct > 0;
                } else if (currentFilter === 'copresence') {
                    return e.copresence > 0;
                }
                return true;
            });

            g.selectAll('*').remove();

            link = g.append('g')
                .selectAll('line')
                .data(filteredEdges)
                .join('line')
                .attr('class', d => {
                    if (currentFilter === 'direct') {
                        return 'link link-direct';
                    } else if (currentFilter === 'copresence') {
                        return 'link link-copresence';
                    } else {
                        if (d.direct > d.copresence) {
                            return 'link link-direct';
                        }
                        return 'link link-copresence';
                    }
                })
                .attr('stroke-width', d => {
                    if (currentFilter === 'direct') {
                        return Math.sqrt(d.direct) * 0.8;
                    } else if (currentFilter === 'copresence') {
                        return Math.sqrt(d.copresence) * 0.8;
                    } else {
                        return Math.sqrt(d.weight) * 0.8;
                    }
                })
                .attr('stroke-opacity', 0.6);

            node = g.append('g')
                .selectAll('circle')
                .data(filteredNodes)
                .join('circle')
                .attr('class', d => {
                    let classes = ['node'];
                    if (d.meta_identity === 'Vampirul') {
                        if (d.identity_type === 'avatar') {
                            classes.push('vampire-avatar');
                        } else if (d.identity_type === 'true_form') {
                            classes.push('vampire-true-form');
                        } else if (d.identity_type === 'merged') {
                            classes.push('vampire-merged');
                        }
                    }
                    return classes.join(' ');
                })
                .attr('r', d => {
                    if (d.identity_type === 'merged') {
                        return Math.max(20, Math.sqrt(d.dialogue_count) * 3);
                    }
                    return Math.max(5, Math.sqrt(d.dialogue_count) * 2);
                })
                .attr('fill', d => {
                    if (d.identity_type === 'merged') {
                        return '#8b5cf6';
                    }
                    return communityColors[d.community % communityColors.length];
                })
                .attr('stroke', d => {
                    if (d.meta_identity === 'Vampirul' && d.identity_type === 'avatar') {
                        return '#ef4444';
                    }
                    if (d.identity_type === 'merged') {
                        return '#8b5cf6';
                    }
                    return '#fff';
                })
                .attr('stroke-width', d => {
                    if (d.meta_identity === 'Vampirul') return 3;
                    return 2;
                })
                .call(drag(simulation))
                .on('mouseover', handleNodeHover)
                .on('mouseout', handleNodeOut)
                .on('click', handleNodeClick);

            label = g.append('g')
                .selectAll('text')
                .data(filteredNodes)
                .join('text')
                .attr('class', 'node-label')
                .attr('text-anchor', 'middle')
                .attr('dy', d => Math.max(5, Math.sqrt(d.dialogue_count) * 2) + 15)
                .text(d => d.label)
                .style('fill', '#e8eaed')
                .style('display', showLabels ? 'block' : 'none');

            simulation.nodes(filteredNodes);
            simulation.force('link').links(filteredEdges);
            simulation.alpha(1).restart();

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
        }

        function handleNodeHover(event, d) {
            const genderIcon = genderIcons[d.gender] || genderIcons['Unknown'];
            const genderLabel = d.gender === 'M' ? 'Male' : 
                                d.gender === 'F' ? 'Female' : 
                                d.gender === 'C' ? 'Collective' : 'Unknown';
            
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-title">${d.label}</div>
                <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Gender:</span>
                    <span class="tooltip-stat-value">${genderIcon} ${genderLabel}</span>
                </div>
                <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Dialogues:</span>
                    <span class="tooltip-stat-value">${d.dialogue_count}</span>
                </div>
                <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Connections:</span>
                    <span class="tooltip-stat-value">${d.degree}</span>
                </div>
                <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Centrality:</span>
                    <span class="tooltip-stat-value">${d.degree_centrality.toFixed(3)}</span>
                </div>
                <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Betweenness:</span>
                    <span class="tooltip-stat-value">${d.betweenness_centrality.toFixed(3)}</span>
                </div>
                <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Community:</span>
                    <span class="tooltip-stat-value">${d.community}</span>
                </div>
            `;
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
            tooltip.style.opacity = 1;

            const connectedNodeIds = new Set();
            link.each(function(l) {
                if (l.source.id === d.id || l.target.id === d.id) {
                    connectedNodeIds.add(l.source.id);
                    connectedNodeIds.add(l.target.id);
                    d3.select(this).classed('highlighted', true);
                } else {
                    d3.select(this).classed('dimmed', true);
                }
            });

            node.each(function(n) {
                if (connectedNodeIds.has(n.id)) {
                    d3.select(this).classed('highlighted', true);
                } else {
                    d3.select(this).classed('dimmed', true);
                }
            });
        }

        function handleNodeOut() {
            document.getElementById('tooltip').style.opacity = 0;
            link.classed('highlighted', false).classed('dimmed', false);
            node.classed('highlighted', false).classed('dimmed', false);
        }

        function handleNodeClick(event, d) {
            console.log('Clicked node:', d);
            openDrawer(d);
        }

        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }

        function setupControls() {
            const minDialoguesSlider = document.getElementById('min-dialogues');
            const minDialoguesValue = document.getElementById('min-dialogues-value');
            minDialoguesSlider.addEventListener('input', (e) => {
                minDialoguesValue.textContent = e.target.value;
                renderNetwork();
            });

            const minWeightSlider = document.getElementById('min-weight');
            const minWeightValue = document.getElementById('min-weight-value');
            minWeightSlider.addEventListener('input', (e) => {
                minWeightValue.textContent = e.target.value;
                renderNetwork();
            });

            document.querySelectorAll('[data-filter]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-filter]').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentFilter = e.target.dataset.filter;
                    renderNetwork();
                });
            });

            document.getElementById('toggle-labels').addEventListener('click', () => {
                showLabels = !showLabels;
                label.style('display', showLabels ? 'block' : 'none');
            });

            document.getElementById('reset-zoom').addEventListener('click', () => {
                svg.transition().duration(750).call(
                    zoom.transform,
                    d3.zoomIdentity
                );
            });

            document.getElementById('vampire-toggle').addEventListener('click', () => {
                toggleVampireMerge();
            });

            document.getElementById('export-svg').addEventListener('click', () => {
                const svgData = svg.node().outerHTML;
                const blob = new Blob([svgData], {type: 'image/svg+xml'});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'character-network.svg';
                link.click();
            });

            document.getElementById('export-png').addEventListener('click', () => {
                const svgData = svg.node().outerHTML;
                const canvas = document.createElement('canvas');
                const bbox = svg.node().getBBox();
                canvas.width = bbox.width + 100;
                canvas.height = bbox.height + 100;
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);
                
                img.onload = function() {
                    ctx.fillStyle = '#0a0e1a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 50, 50);
                    URL.revokeObjectURL(url);
                    
                    canvas.toBlob(function(blob) {
                        const pngUrl = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = pngUrl;
                        link.download = 'character-network.png';
                        link.click();
                    });
                };
                
                img.src = url;
            });
        }

        loadData();
    </script>
    </body>
</html>